纯真ip库的解析
-----

## 存储结构分析

[纯真IP库](https://www.cz88.net/)是一个二进制文件打包了起始IP、终止IP、记录A和记录B共4部分数据。二进制文件整体分为三个区域：[头部区]、[记录区]和[索引区]。

[头部区]共8个字节，前4个字节指示了[索引区]的开始地址和最后一条索引的地址偏移量

[记录区]存放了终止IP数据、RecordA和记录RecordB。记录区每条记录前4个字节为终止ip，后面跟着记录A和记录B的信息，为了节省空间，纯真ip库使用了重定向机制。记录A和记录B使用GBK编码存储。

[索引区]存放的是起始IP和指向记录区地址偏移量。每条索引占用7个字节，前4个字节存起始IP，后3个字节存偏移量。

我们用hexdump来查看一下文件

```sh
hexdump -n 32 qqwry.dat
```

结果为（结果中的-是为了方便查看手动添加的）

```
[hexdump结果1]
0000000 7b 9e 66 00 92 1f 9f 00 - ff ff ff 00 49 41 4e 41
0000010 00 b1 a3 c1 f4 b5 d8 d6 - b7 00 00 00 00 01 c3 c0
0000020
```

根据上面的介绍可以得知，[0000000]位置开始的头8个字节"7b 9e 66 00 92 1f 9f 00"应该是索引区的偏移量 这边使用的是小端存储，所以我们记录索引区 第一条记录的偏移量
indexStartPos=0x00669e7b 最后一条记录的偏移量 indexEndPos=0x009f1f92。

顺便看下[索引区]后面跟着是记录区，记录区的头4个字节是一个IP段终止IP的地址，也就是说后面跟着的"ff ff ff 00"应该指示的是一个IP地址（这个后面分析）。 再后面的的"49 41 4e 41 00"
应该就是这条记录的RecordA的内容了（记录区的内容都是遇0x00表示结束）。 找一个 [GBK解码网站](https://www.qqxiuzi.cn/bianma/zifuji.php) 查一下，"49 41 4e 41"就是"
IANA"的ASCII码表示（GBK是兼容ASCII嘛的，对于ASCII码依然使用一位存储，中文使用两位存储）。

"49 41 4e 41 00"后面跟着的"b1 a3 c1 f4 b5 d8 d6 b7 00"应该就是RecordB的内容了。这里就不像是ASCII码了，我们把每两位合并起来得到"b1a3 c1f4 b5d8 d6b7"
，再使用上述GBK网站查询得到结果"保留地址"。 可见这边GBK也是采用大端存放的。（关于大端和小端我的理解就是数据在存储器中是正过来放还是反过来放，大端符合人类的正常思维，计算机内部小端用的更多）。

到这里我们就分析出了[头部区]和[记录区]的大概格式，刚好第一条记录区的数据是没有重定向的，比较简单，终止ip后面直接跟着RecordA和RecordB的数据。

然后我们分析[索引区]，使用上面分析得出的索引区偏移量继续hexdump

```sh
hexdump -n 32 -s 0x00669e7b qqwry.dat #-s表示设置偏移量
hexdump -n 32 -s 0x009f1f92 qqwry.dat

```

结果分别为：

```
[hexdump结果2]
0669e7b 00 00 00 00 08 00 00 00 - 00 00 01 1a 00 00 01 00
0669e8b 00 01 48 00 00 02 00 00 - 01 6e 00 00 00 01 00 01
0669e9b

[hexdump结果3]
09f1f92 00 ff ff ff 59 9e 66                           
09f1f99

```

先看结果3，很好理解："00 ff ff ff"就是最后一条ip记录，后面的"59 9e 66"是一个指向记录区的偏移量。虽然打印了32个字节，这里只显示了7个字节，是因为文件到此就结束了。

ipv4地址本质上是一个数值，使用小端方式存储占用4个字节，"00 ff ff ff"的ipv4文本形式其实就是255.255.255.0。 后面跟着的"59 9e 66"
是一个偏移量只有3个字节，是因为纯真ip库尺寸不大，而且记录区实在中间的（偏移数值比较小），所以3个字节完全存的下。 再实际使用的时候我们还需要去补0的，这里的偏移量实际应该是0x00669e59。

再看结果2就更好理解了，32个字节包含了32/7=4个索引，我们按长度排列一下得到：

```
[分析结果]
00 00 00 00 - 08 00 00 => ip 0.0.0.0 offset 0x08
00 00 00 01 - 1a 00 00 => ip 1.0.0.0 offset 0x1a
01 00 00 01 - 48 00 00 => ip 1.0.0.1 offset 0x48
02 00 00 01 - 6e 00 00 => ip 1.0.0.2 offset 0x6e
```

看分析结果的第一条记录起始ip="0.0.0.0"，偏移量8正好指向[hexdump结果1]分析的第一条记录区"ff ff ff 00 49 41 4e 41"。 所以这条记录的完整信息为：

```
起始ip   0.0.0.0 
终止ip   0.255.255.255 
RecordA IANA
RecordB 保留地址
```

用上述方法再分析出最后一条ip记录

```
起始ip   255.255.255.0
终止ip   255.255.255.255 
RecordA 纯真网络 
RecordB 2021年04月14日IP数据 
```

这条记录没有实际意义，可以用来显示纯真ip库的版本号

## 索引的查找

可见，纯真ip库是将所以的ipv4的可能ip进行分区存放，任何有效的ipv4地址都会被匹配到一个区段中。索引区是固定每条索引占用7个字节的，所以需要查找所属区间也很简单，使用折半查找（二分查找）即可取得非常好的查询效率。
2021年04月14日IP数据 共有数据：529010 条，采用折半查找最多只需要查询20次就能查询成功。之后再根据偏移量继续查询相关记录信息。

## 记录区的重定向

分析到这里，纯真ip库的数据存放结构大体就清楚了，但是记录区中很多数据是重复的，所以为了压缩ip库的文件大小，官方使用了内容重定向。
简单来说就是终止ip后跟着的第一个字节的数据，如果是0x01或者0x02就表示该条记录的文本区域重定向走了（正常的字符不可能是0x01或者0x02，所以可以做区分），0x01或者0x02后面跟的就是新的偏移地址。

0x01和0x02这两种重定向有所不同，0x01是整体重定向，0x02是局部重定向。

0x02局部重定向表示当前的RecordA或者RecordB被重定向到了另一个地方，0x02后面跟着4个字节的就是偏移量，根据偏移量重新去查。 这里就有多种情况：

- RecordA和RecordB都没有重定向 （就是上面分析的第一条ip记录的情况）
- 只有RecordA重定向了，RecordB未重定向
- 只有RecordB重定向了，RecordA未重定向
- RecordA和RecordB都重定向了

关于0x02的重定向可以使用一个递归函数处理，如果是0x02就递归调用当前函数。这样就封装除了一个读取RecordA/RecordB的递归函数，而无需考虑局部重定向的处理。递归最多调用1次，也不会造成过多栈上资源的浪费。

如果读到了0x01整体重定向，表示RecordA和RecordB都在另一个地方，直接去新的地址查询。（也就意味着0x01只会跟在终止ip后面）。
但是这里有一点要注意。当遇到0x01整体重定向到新的偏移地址时，依然可能会遇到0x02的局部重定向的情况（可见这里又是一个递归处理）

关于0x01整体依然可以使用一个递归函数进行处理。当遇到最复杂的情况（先是整体重定向，然后RecordA和RecordB分别局部重定向）也只会有个位数的递归调用，无需担心性能。相比使用if/else判断各种情况要逻辑清晰的多。

## 性能分析

至此为止，一个ip归属地查询的一次函数调用的流程就很清晰了：ip字符串转成数值形式，折半查找所属ip区间以及记录区的偏移量，再根据偏移量去读取相关记录。
如果每次使用文件io的方式去查询效率就太低了（当然也有好处：节省内存。但是使用场景非常有限）。所以一般会把整个ip库文件载入内存使用字节切片[]byte存储，
这样无论是读取内容还是进行偏移操作都非常方便和高效（当然要牺牲一点点内存作为代价）。

如果想要进一步提升查询效率，就要在索引查找和记录值读取上做点文章了。索引查找目前除了折半查找外还没有想到更好的办法，

但是记录值读取上还是有优化空间的：原方法每次定位到ip区间后都需要去读取记录，读取到之后还需要进行GBK的解码，这两部操作都是需要花时间的。
那就干脆再浪费一些内存，初始化的时候把所有的ip的记录值都读取出来保存到一个map中，直接使用hashmap高效的Get操作（时间复杂度O(1)）来直接获取格式化后的记录值。

经过初步的测试，这种方法会将内存占用从30M提升到90M左右，初始化map也需要大约500ms的时间。但是基准测试结果查询性能确实可以提高1-2倍。
